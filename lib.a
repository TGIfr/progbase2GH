!<arch>
csv.c/          0           0     0     644     4033      `
//
// Created by tgifr on 26.02.17.
//

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "csv.h"


#define MAX_TOKENS 100

const char * const StandardDelimiter = ";";
List * readCsv(char * readFile){
    List * result = List_new();
    FILE * read;
    if((read = fopen(readFile, "r")) == NULL) {
        printf("Error: can't open file");
        exit(1);
    }
    char temp[200] ;
    char **out;
    while(!feof(read)){
        fgets(temp, 200, read);
        out = NULL;
        int size = getcols(temp, StandardDelimiter, &out);
        Student * new = Student_new(out[0], atoi(out[1]), (float)atof(out[2]));
        List_add(result, new);
    }
    fclose(read);
    return result;
}
void saveCsv(List * list, char * saveFile){
    FILE * save ;
    if((save = fopen(saveFile, "w")) == NULL){
        printf("Error: can't open save file");
        exit(2);
    }
    int length = List_count(list);
    for (int i = 0; i < length; ++i) {
        Student * temp = List_get(list, i);
        fprintf(save, "%s;%i;%f\n", Student_getName(temp), Student_getCourse(temp), Student_getMark(temp));
    }
    fclose(save);
}

int getcols( const char * const line, const char * const delim, char ***out_storage ) {
    const char *start_ptr, *end_ptr, *iter;
    char **out;
    int i;
    int tokens_found = 1, delim_size, line_size;
    int start_idx[MAX_TOKENS], end_idx[MAX_TOKENS];

    if ( *out_storage != NULL )                 return -4;  //This SHOULD be NULL: Not Already Allocated
    if ( !line || !delim )                      return -1;  //NULL pointers Rejected Here
    if ( (delim_size = (int)strlen( delim )) == 0 )  return -2;  //Delimiter not provided

    start_ptr = line;   //Start visiting input. We will distinguish tokens in a single pass, for good performance.
    //Then we are allocating one unified memory region & doing one memory copy.
    while ( ( end_ptr = strstr( start_ptr, delim ) ) ) {
        start_idx[ tokens_found -1 ] = (int)(start_ptr - line);    //Store the Index of current token
        end_idx[ tokens_found - 1 ] = (int)(end_ptr - line); //Store Index of first character that will be replaced with
        //'\0'
        tokens_found++;                                     //Accumulate the count of tokens.
        start_ptr = end_ptr + delim_size;                   //Set pointer to the next c-string within the line
    }

    for ( iter = start_ptr; (*iter!='\0') ; iter++ );

    start_idx[ tokens_found -1 ] = (int)(start_ptr - line);    //Store the Index of current token: of last token here.
    end_idx[ tokens_found -1 ] = (int)(iter - line);           //and the last element that will be replaced with \0

    line_size = (int)(iter - line);    //Saving CPU cycles: Indirectly Count the size of *line without using strlen();

    int size_ptr_region = (1 + tokens_found)*sizeof( char* );   //The size to store pointers to c-strings + 1 (*NULL).
    out = (char**) malloc( (size_t)size_ptr_region + ( line_size + 1 ) + 5 );
    //It reserves a contiguous space for both (char**) pointers AND string region. 5 Bytes for "Out of Range" tests.
    *out_storage = out;     //Update the char** pointer of the caller function.

    for ( i = 0; i < tokens_found; i++ )    //Assign adresses first part of the allocated memory pointers that point to
        out[ i ] = (char*) out + size_ptr_region + start_idx[ i ];  //the second part of the memory, reserved for Data.
    out[ tokens_found ] = (char*) NULL; //[ ptr1, ptr2, ... , ptrN, (char*) NULL, ... ]: We just added the (char*) NULL.
    //Now assign the Data: c-strings. (\0 terminated strings):
    char *str_region = (char*) out + size_ptr_region;   //Region inside allocated memory which contains the String Data.
    memcpy( str_region, line, line_size );   //Copy input with delimiter characters: They will be replaced with \0.

    //Now we should replace: "arg1||arg2||arg3" with "arg1\0|arg2\0|arg3"
    for( i = 0; i < tokens_found; i++) str_region[ end_idx[ i ] ] = '\0';

    return tokens_found;
}
list.c/         0           0     0     644     3731      `
//
// Created by tgifr on 26.02.17.
//

#include <malloc.h>
#include <assert.h>
#include "list.h"

struct Student{
    char * name;
    int course;
    float mark;
};
struct Teacher {
    char * Name;
    List * list;
};

Teacher * Teacher_new(char * name){
    Teacher * res = malloc(sizeof(Teacher));
    res->Name = name;
    res->list = NULL;
    return res;
}
void Teacher_free(Teacher ** teacher){
    free(*teacher);
    *teacher = NULL;
}
void Teacher_attachList(Teacher * teacher, List * toAttach){
    teacher->list = toAttach;
}
char * Teacher_getName(Teacher * teacher){
    return teacher->Name;
}
List * Teacher_getList(Teacher * teacher){
    return teacher->list;
}

List * separateLists(Teacher * first, Teacher * second){
    List * result = List_new();
    List * firstList = Teacher_getList(first);
    List * secondList = Teacher_getList(second);
    int length = List_count(secondList);
    for (int i = 0; i < length; ++i) {
        Student * temp = List_get(secondList, i);
        if(List_contains(firstList, temp) == 0){
            List_add(result, Student_new(Student_getName(temp), Student_getCourse(temp), Student_getMark(temp)));
        }
    }
    return result;
}


Student * Student_new(char * name, int course, float mark){
    Student * new = malloc(sizeof(Student));
    new->course = course;
    new->name = name;
    new->mark = mark;
    return new;
}
char * Student_getName(Student * stud){
    return stud->name;
}
int Student_getCourse(Student *stud){
    return stud->course;
}
float Student_getMark(Student *stud){
    return stud->mark;
}
void Student_free(Student ** self){
    free(*self);
    *self = NULL;
}


#define throw(MSG) assert(0 && MSG);

struct List {
    size_t capacity;
    size_t size;
    void ** items;    /**< holds a pointer to items array */
};

static const int initialCapacity = 4;

static void __ensureCapacity(List * self, size_t min);

List * List_new(void) {
    List * self = malloc(sizeof(struct List));
    self->capacity = initialCapacity;
    self->size = 0;
    self->items = malloc(0);
    __ensureCapacity(self, 0);
    return self;
}

void List_free(List ** selfPtr) {
    if (selfPtr == NULL) throw("Null pointer on free()");
    List * self = *selfPtr;
    free(self->items);
    free(self);
    *selfPtr = NULL;
}

void * List_get(List * self, int index) {
    if (index < 0 || index >= self->size) throw("Index out of bounds");
    return self->items[index];
}
void List_set(List * self, int index, void * ref) {
    if (ref == NULL) throw("NULL reference");
    if (index < 0 || index >= self->size) throw("Index out of bounds");
    self->items[index] = ref;
}
void List_add(List * self, void * ref) {
    if (ref == NULL) throw("NULL reference");
    if (self->size <= self->capacity) {
        __ensureCapacity(self, self->size + 1);
    }
    List_set(self, self->size++, ref);
}


int List_indexOf(List * self, void * ref) {
    if (ref == NULL) throw("NULL reference");
    for (int i = 0; i < self->size; i++) {
        if (self->items[i] == ref) {
            return i;
        }
    }
    return -1;
}

int List_contains(List * self, void * ref) {
    if (ref == NULL) throw("NULL reference");
    return List_indexOf(self, ref) >= 0;
}



int List_isEmpty(List * self) {
    return self->size == 0;
}

int  List_count(List * self) {
    return self->size;
}


static void __ensureCapacity(List * self, size_t min) {
    if (self->size <= min) {
        int newCapacity = self->size == 0 ? initialCapacity : self->size * 2;
        if (newCapacity < min) newCapacity = min;
        self->capacity = newCapacity;
        size_t newSize = sizeof(void *) * self->capacity;
        self->items = realloc(self->items, newSize);
    }
}


